比如现在要计算北京、天津、广东、新疆这四个城市的一条最优路径，但算法程序不能够直接处理北京、天津、广东、新疆这些数据，所以我们得给 它们编上号，北京（0）、天津（1）、广东（2）、新疆（3），路径（天津->新疆->北京->广东）可以表示成基因型串结构数据 （1302），这样算法程序只要直接处理它们的编号就行了。
（1）二进制编码，基因用0或1表示（常用于解决01背包问题）
​
如：基因A：00100011010 (代表一个个体的染色体)
​
（2）互换编码（用于解决排序问题，如旅行商问题和调度问题）
​
如旅行商问题中，一串基因编码用来表示遍历的城市顺序，如：234517986，表示九个城市中，先经过城市2，再经过城市3，依此类推。



（1）单交叉点法 （用于二进制编码）
​
选择一个交叉点,子代在交叉点前面的基因从一个父代基因那里得到,后面的部分从另外一个父代基因那里得到。
​
如：交叉前：
​
00000|01110000000010000
​
11100|00000111111000101
​
交叉后：
​
00000|00000111111000101
​
11100|01110000000010000
​
（2）双交叉点法 （用于二进制编码）
​
选择两个交叉点,子代基因在两个交叉点间部分来自一个父代基因,其余部分来自于另外一个父代基因.
​
如：交叉前：
​
01 |0010| 11
​
11 |0111| 01
​
交叉后：
​
11 |0010| 01
​
01 |0111| 11
​
（3）基于“ 与/或 ”交叉法 （用于二进制编码）
​
对父代按位"与”逻辑运算产生一子代A;按位”或”逻辑运算产生另一子代B。该交叉策略在解背包问题中效果较好 .
​
如：交叉前：
​
01001011
​
11011101
​
交叉后：
​
01001001
​
11011111
​
（4）单交叉点法 （用于互换编码）
​
选择一个交叉点，子代的从初始位置出发的部分从一个基因复制，然后在另一个基因中扫描，如果某个位点在子代中没有，就把它添加进去。
​
如：交叉前：
​
87213 | 09546
​
98356 | 71420
​
交叉后：
​
87213 | 95640
​
98356 | 72104
​
（5）部分匹配交叉（PMX）法（用于互换编码）
​
先随机产生两个交叉点，定义这两点间的区域为匹配区域，并用交换两个父代的匹配区域。
​
父代A：872 | 130 | 9546
​
父代B：983 | 567 | 1420    变为：
​
TEMP A: 872 | 567 | 9546
​
TEMP B: 983 | 130 | 1420
​
对于 TEMP A、TEMP Ｂ中匹配区域以外出现的数码重复，要依据匹配区域内的位置逐一进行替换。匹配关系：1<——>５　３<——>６　７<——>０
​
子代Ａ：802 | 567 | 9143
​
子代Ｂ：986 | 130 | 5427
​
（6）顺序交叉法(OX) （用于互换编码）
​
从父代Ａ随机选一个编码子串，放到子代Ａ的对应位置；子代Ａ空余的位置从父代Ｂ中按Ｂ的顺序选取（与己有编码不重复）。同理可得子代Ｂ。
​
父代A: 872 | 139 | 0546
​
父代B: 983 | 567 | 1420
​
交叉后：
​
子代A: 856 | 139 | 7420
​
子代B: 821 | 567 | 3904
​
（7）循环交叉（CX）（用于互换编码）
​
CX同OX交叉都是从一个亲代中取一些城市，而其它城市来自另外一个亲代，但是二者不同之处在于：OX中来自第一个亲代的编码子串是随机产生的，而CX却不是，它是根据两个双亲相应位置的编码而确定的。
​
父代A：1 2 3 4 5 6 7 8 9
​
父代B：5 4 6 9 2 3 7 8 1
​
可得循环基因：1->5->2->4->3->6->9->7->8
​
子代Ｂ的编码同理。（循环基因 5->1->4->2->6->3->9->7->8）
